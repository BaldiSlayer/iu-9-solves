# Разбор задачи I. Цифровой баскетбол с Moscow Regional Contest Qualification 2022 год

## Условие
Известный сторонник цифрового баскетбола Дэрил не смотрит матчей NBA — ему достаточно протокола со статистикой. Даже с самой базовой, вроде порядка набора очков командами в четверти.

Протокол набора очков составляется следующим образом:

* Матч начинается со счёта 0:0. В случае, если бросок команды хозяев попал в цель, стоимость броска добавляется к первому числу, если бросок команды гостей попал в цель — стоимость броска добавляется ко второму числу.
* Записывается каждый успешный бросок (то есть бросок, повлиявший на счёт), а также информация о конце текущей части матча (основной четверти или — при необходимости — овертайма).
* Броски бывают стоимостью в 1, 2 или 3 очка. Запись состоит из номера команды, набравшей очки (первая - хозяева площадки, вторая - гости) и количества набранных за бросок очков.
* Запись о конце текущей четверти/овертайма не имеет дополнительных параметров.
* Если после 4 четвертей счёт в матче ничейный, играется дополнительная четверть (овертайм), если счёт и после овертайма ничейный — играется ещё один овертайм и так далее.
* Известно, что в текущем сезоне не было матчей более, чем с тремя овертаймами.

Дэрил считает два матча одинаковыми, если их протоколы совпадают. Вам дан счёт матча — количество очков, набранных командой хозяев, и количество очков, набранных командой гостей. Найдите количество различных матчей с точки зрения Дэрила (то есть количество различных возможных протоколов).

Так как ответ может быть слишком большим, выведите остаток от его деления на `998244353`.

## Формат ввода
Входные данные содержат два целых числа `h` и `g` — количество очков, набранных первой и второй командами соответственно (`0 ≤ h,g ≤ 180, h ≠ g`).

## Формат вывода
Выведите одно целое число — остаток от деления количества возможных различных протоколов на `998244353`.

# Разбор

Заведем динамику `dp[i][j][k]`, которая означает количество комбинаций набрать счет `i:j` в тайме под номером `k` (тайм - общее обозначение части игры, либо четверти,
либо овертайма). База нашей динамики - `dp[0][0][1] = 1`, потому что получить счет `0:0` в первом тайме можно единственным способом, когда обе команды не забьют.

Тогда получим следующий код:


```cpp
#pragma GCC optimize("unroll-loops", "O3")

#include <iostream>
#include <vector>

using namespace std;

typedef long long ll;

ll mod = 998244353;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);

	ll h, g;
	cin >> h >> g;

	vector<vector<vector<ll>>> dp(h+1, vector<vector<ll>>(g+1, vector<ll>(7+1, 0)));
	// счет 0 0 в первом тайме мы можем получить единственным способом
	dp[0][0][1] = 1;

	// идем по четвертям и овертаймам
	for (int k = 1; k <= 7; ++k) {
		// итерируемся по голам хозяев
		for (int i = 0; i <= h; ++i) {
			// итерируемся по голам гостей
			for (int j = 0; j <= g; ++j) {
        			// если выполняются условия, то пересчитываемся через предыдущий тайм
				if ((k > 1 && k <= 4) || (k >= 5 && i == j)) {
					dp[i][j][k] = dp[i][j][k-1] % mod;
				}

        			// если ничего не забили
				if (i == 0 && j == 0) {
					continue;
				}

				// забиваем за хозяев
				for (int l = 1; l <= 3 && i - l >= 0; ++l) {
					dp[i][j][k] = (dp[i][j][k] + dp[i - l][j][k]) % mod;
				}

				// забиваем за гостей 
				for (int l = 1; l <= 3 && j - l >= 0; ++l) {
					dp[i][j][k] = (dp[i][j][k] + dp[i][j - l][k]) % mod;
				}
			}
		}
	}

	// считаем и выводим ответ
	ll ans = 0;
	for (int k = 4; k <= 7; ++k) {
		ans = (ans + dp[h][g][k]) % mod;
	}

	cout << ans;

	return 0;
}
```

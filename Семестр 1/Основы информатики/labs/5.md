```scheme
(define (get_command_index token program index)
  (if (equal? (vector-ref program index) token)
      index
      (get_command_index token program (+ 1  index))))

(define (interpret program init-stack)
  (let solver ((index 0) (stack init-stack) (stack_ret '()) (dictionary_ '()))
    (if (= index (vector-length program))
        stack
        (let ((command (vector-ref program index)))
          (cond
            ((number? command) (solver (+ 1  index) (cons command stack) stack_ret dictionary_))
            ((equal? command '+) (solver (+ 1  index)
                                         (cons (+ (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command '-) (solver (+ 1  index)
                                         (cons (- (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command '*) (solver (+ 1  index)
                                         (cons (* (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command '/) (solver (+ 1  index)
                                         (cons (quotient (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command 'mod) (solver (+ 1  index) (cons (remainder (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command '=) (solver (+ 1  index)
                                         (cons (if (= (cadr stack) (car stack)) -1 0) (cddr stack)) stack_ret dictionary_))
            ((equal? command '>) (solver (+ 1  index)
                                         (cons (if (> (cadr stack) (car stack)) -1 0) (cddr stack)) stack_ret dictionary_))
            ((equal? command '<) (solver (+ 1  index)
                                         (cons (if (< (cadr stack) (car stack)) -1 0) (cddr stack)) stack_ret dictionary_))                
            ((equal? command 'and) (solver (+ 1  index)
                                           (cons (if (and (= (car stack) -1) (= (cadr stack) -1)) -1 0) (cddr stack)) stack_ret dictionary_))
            ((equal? command 'or) (solver (+ 1  index)
                                          (cons (if (or (= (car stack) -1) (= (cadr stack) -1)) -1 0) (cddr stack)) stack_ret dictionary_))
            ((equal? command 'neg) (solver (+ 1  index)
                                           (cons (- (car stack)) (cdr stack)) stack_ret dictionary_))
            ((equal? command 'not) (solver (+ 1  index)
                                           (cons (if (= (car stack) 0) -1 0) (cdr stack)) stack_ret dictionary_))
            ((equal? command 'drop) (solver (+ 1  index)
                                            (cdr stack) stack_ret dictionary_))
            ((equal? command 'swap) (solver (+ 1  index)
                                            (append (list (cadr stack) (car stack)) (cddr stack)) stack_ret dictionary_))
            ((equal? command 'dup) (solver (+ 1  index)
                                           (cons (car stack) stack) stack_ret dictionary_))
            ((equal? command 'over) (solver (+ 1  index)
                                            (cons (cadr stack) stack) stack_ret dictionary_))
            ((equal? command 'rot) (solver (+ 1  index)
                                           (append (list (caddr stack) (cadr stack) (car stack)) (cdddr stack)) stack_ret dictionary_))
            ((equal? command 'depth) (solver (+ 1  index)
                                             (cons (length stack) stack) stack_ret dictionary_))
            ((equal? command 'define) (solver (+ 1  (get_command_index 'end program index)) stack stack_ret
                                              (cons (list (vector-ref program (+ 1  index)) (+ index 2)) dictionary_)))            
            
            ((equal? command 'end) (solver (car stack_ret) stack (cdr stack_ret) dictionary_))
            ((equal? command 'exit) (solver (car stack_ret) stack (cdr stack_ret) dictionary_))
            
            ((equal? command 'if) (solver (if (zero? (car stack)) (+ 1  (get_command_index 'endif program index)) (+ 1  index)) (cdr stack) stack_ret dictionary_))
            ((equal? command 'endif) (solver (+ 1  index) stack stack_ret dictionary_))
            ((equal? command 'while) (if (zero? (car stack))
                                         (solver (+ 1  (get_command_index 'endwhile program index)) stack stack_ret dictionary_)
                                         (solver (+ 1  index) stack (cons index stack_ret) dictionary_)))
            
            ((equal? command 'endwhile) (solver (car stack_ret) stack (cdr stack_ret) dictionary_))
            ((equal? command 'do) (solver (+ 1  index) stack (cons index stack_ret) dictionary_))
            ((equal? command 'until) (solver (if (zero? (car stack)) (+ 1  index) (car stack_ret)) stack (cdr stack_ret) dictionary_))
            ((equal? command 'for) (if (<= (car stack) (cadr stack))
                                       (solver (+ 1  index) stack (cons index stack_ret) dictionary_)
                                       (solver (+ 1  (get_command_index 'endfor program index)) (cddr stack) stack_ret dictionary_)))
            ((equal? command 'endfor) (solver (car stack_ret) (cons (+ 1  (car stack)) (cdr stack)) (cdr stack_ret) dictionary_))
            (else (solver (cadr (assoc command dictionary_)) stack (cons (+ 1  index) stack_ret) dictionary_)))))))


(interpret #(define -- 1 - end
              define =0? dup 0 = end
              define =1? dup 1 = end
              define factorial
              =0? if drop 1 exit endif
              =1? if drop 1 exit endif
              dup --
              factorial
              *
              end
              0 factorial
              1 factorial
              2 factorial
              3 factorial
              4 factorial)
           '())







```

```scheme

(define (interpret program stack)
  (let interpret-internal ((stack stack)
                           (index 0)
                           (dictionary '()))
    (if (= index (vector-length program))
        stack
        (let ((command (vector-ref program index)))
          ;; выполнение операций со стеком и переход к выполнению следующей команды (слова)
          (let-syntax ((next-with-new-stack (syntax-rules ()
                                              ((_ new-stack)
                                               (interpret-internal new-stack
                                                                   (+ index 1)
                                                                   dictionary)))))
            (if (number? command)
                (next-with-new-stack (cons command stack))
                ;; проверяем какая это команда с помощью case
                (case command
                  (+ (next-with-new-stack (cons (+ (cadr stack) (car stack))
                                                (cddr stack))))
                  (- (next-with-new-stack (cons (- (cadr stack) (car stack))
                                                (cddr stack))))
                  (* (next-with-new-stack (cons (* (cadr stack) (car stack))
                                                (cddr stack))))
                  (/ (next-with-new-stack (cons (quotient (cadr stack) (car stack))
                                                (cddr stack))))
                  (mod (next-with-new-stack (cons (remainder (cadr stack) (car stack))
                                                  (cddr stack))))
                  (neg (next-with-new-stack (cons (- (car stack))
                                                  (cdr stack))))
                  (= (next-with-new-stack (cons (if (= (cadr stack) (car stack))
                                                    -1
                                                    0)
                                                (cddr stack))))
                  (< (next-with-new-stack (cons (if (< (cadr stack) (car stack))
                                                    -1
                                                    0)
                                                (cddr stack))))
                  (> (next-with-new-stack (cons (if (> (cadr stack) (car stack))
                                                    -1
                                                    0)
                                                (cddr stack))))
                  (not (next-with-new-stack (cons (if (equal? (car stack) 0)
                                                      -1
                                                      0)
                                                  (cdr stack))))
                  (and (next-with-new-stack (cons (if (and (not (equal? (car stack) 0))
                                                           (not (equal? (cadr stack) 0)))
                                                      -1
                                                      0)
                                                  (cddr stack))))
                  (or (next-with-new-stack (cons (if (or (not (equal? (car stack) 0))
                                                         (not (equal? (cadr stack) 0)))
                                                     -1
                                                     0)
                                                 (cddr stack))))
                  (drop (next-with-new-stack (cdr stack)))
                  (swap (next-with-new-stack (cons (cadr stack)
                                                   (cons (car stack) (cddr stack)))))
                  (dup (next-with-new-stack (cons (car stack) stack)))
                  (over (next-with-new-stack (cons (cadr stack) stack)))
                  (rot (next-with-new-stack (cons (caddr stack)
                                                  (cons (cadr stack)
                                                        (cons (car stack) (cdddr stack))))))
                  ;; число элементов в stack
                  (depth (next-with-new-stack (cons (length stack) stack)))
                  (define (interpret-internal stack
                                              (+ 1 ;; следующее слово за end
                                                 (let loop ((index (+ index 2))) ;; вернет индекс следующего end
                                                   (if (eqv? 'end (vector-ref program index))
                                                       index
                                                       (loop (+ index 1)))))
                                              (cons (list
                                                     (vector-ref program (+ index 1))
                                                     (+ index 2)) ;; (название-статьи индекс-первого-слова-статьи)
                                                    dictionary)))
                  (end stack)
                  (exit stack)

                  ;; если это if - выполняем все инструкции внутри, пока мы не доберемся до endif
                  (if
                   (if (= 0 (car stack))
                       (interpret-internal (cdr stack)
                                           (+ 1
                                              (let loop ((index (+ index 1)))
                                                (if (eqv? 'endif (vector-ref program index))
                                                    index
                                                    (loop (+ index 1)))))
                                           dictionary)
                       (next-with-new-stack (cdr stack))))
                  
                  (endif (next-with-new-stack stack))
                  
                  (else (let ((jmp-index (cadr (assoc command dictionary))))
                          (next-with-new-stack (interpret-internal stack
                                                            jmp-index
                                                            dictionary)))))))))))

(display (interpret #(1 neg) '()))

```

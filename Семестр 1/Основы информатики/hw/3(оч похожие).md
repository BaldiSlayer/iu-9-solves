```scheme
(define (derivative expr)
  (cond
    ((not (list? expr))
     (if (number? expr)
         0
         (if (symbol? expr)
             1)))

    ((null? (cdr expr)) (derivative (car expr)))
    ((and (symbol? (cadr expr)) (equal? '- (car expr))) -1)
    ((equal? '+ (car expr)) `(+ ,@(map derivative (cdr expr))))
    ((equal? '- (car expr)) `(- ,@(map derivative (cdr expr))))

    ((equal? '* (car expr))
     (if (null? (cddr expr))
         (derivative (cadr expr))
         (let ((u (cadr expr))
               (v (if (null? (cdddr expr))
                      (caddr expr)
                      (cons '* (cddr expr)))))
           `(+ (* ,(derivative u) ,v)
               (* ,u ,(derivative v))))))

    ((equal? '/ (car expr))
     (let ((u (cadr expr))
           (v (caddr expr)))
       `(/ (- (* ,(derivative u) ,v)
              (* ,(derivative v) ,u))
           (* ,v ,v))))
    
    ((equal? 'expt (car expr))
     (let ((base (cadr expr))
           (exponent (caddr expr)))
       (if (symbol? base)
           `(* ,exponent (expt ,base ,(- exponent 1)))
           `(* ,expr (log ,base) ,(derivative exponent)))))
    
    ((equal? 'exp (car expr))
     (let ((d (cadr expr)))
       `(* (exp ,d) ,(derivative d))))

    ((equal? 'sin (car expr)) `(* (cos ,(cadr expr)) ,(derivative (cadr expr))))
    
    ((equal? 'cos (car expr)) `(* (- (sin ,(cadr expr))) ,(derivative (cadr expr))))    
    
    
    ((equal? 'log (car expr)) `(/ ,(derivative (cadr expr)) ,(cadr expr)))
    
    (else expr)))

(define (simplify expr)
  (if (not (list? expr))
      expr
      (if (equal? '+ (car expr))
          (let for ((expr (cdr expr))
                    (res '()))
            (if (null? expr)                
                (if (null? res)
                    0
                    (if (null? (cdr res))
                        (car res)
                        (cons '+ (reverse res)))) 
                (let ((cur (simplify (car expr))))
                  (if (equal? cur 0)
                      (for (cdr expr) res)
                      (for (cdr expr) (cons cur res))))))
          (if (equal? '* (car expr))
              (let for ((expr (cdr expr))
                        (res '()))
                (if (null? expr)
                    (if (null? res)
                        1
                        (if (null? (cdr res))
                            (car res)
                            (cons '* (reverse res))))  
                    (let ((cur (simplify (car expr))))

                      (if (equal? cur 0)
                          0
                          (if (equal? cur 1)
                              (for (cdr expr) res)
                              (for (cdr expr) (cons cur res)))))))
              (let for ((expr expr)
                        (res '()))
                (if (null? expr)
                    (reverse res)
                    (for (cdr expr) (cons (simplify (car expr)) res))))))))
     
(define-syntax flatten
  (syntax-rules ()    
    ((smth flatted ... ((lst ...) toflatt ...))
     (flatten flatted ... (lst ... toflatt ...)))
    ((smth flatted ... (action others ...))
     (flatten flatted ... action (others ...)))
    ((smth flatted ... ())
     (flatted ...))))

(define-syntax extract
  (syntax-rules ()
    ((extract (first . others))
     (let ((efirst (extract first))
           (eothers (extract others)))
       ;;(display first)
       ;;(newline)
       (if (and (symbol? 'first) (not (procedure? first)))
           first
           (if (not (equal? 'none efirst))
               efirst
               (if (not (equal? 'none eothers))
                   eothers
                   0))
               
           )))
    ((extract x)
     'none)))

(define-syntax mderivative
  (syntax-rules ()
    ((mderivative expr)
     (begin
       ;;(display 'expr)
       ;;(newline)
       (eval `(letrec ((x ',(extract expr)))
                ,(derivative 'expr))           
             (interaction-environment))))))
 ```

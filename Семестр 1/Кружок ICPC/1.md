# Разбор задачи J. Запросы на ПСП с Moscow Regional Contest Qualification 2022 год

## Условие

Дана правильная скобочная подпоследовательность P = p<sub>1</sub>p<sub>2</sub>...p<sub>n</sub> длины `n` и `q` запросов. Каждый запрос содержит по два целых числа a<sub>i</sub>
и b<sub>i</sub> от 1 до n. Для каждого запроса требуется ответить, будет ли последовательность правильной после обмена скобок p<sub>a<sub>i</sub></sub> и p<sub>b<sub>i</sub></sub>.
Изменения *не накапливаются* - то есть каждый запрос применяется *к исходной* последовательности.

## Формат ввода

## Формат вывода

Для каждого запроса выведите `Yes`, если последовательность остаётся правильной, и `No` в противном случае.

# Разбор

Давайте представим `(` как 1, а `)` как -1. Заметим, что так как исходная строка `S` по условию ПСП, то сумма после такой замены будет равна 0. 
Давайте для подсчета таких сумм на префиксах заведем массив balance длины n (такой же длины, как и данная нам строка) и для каждого индекса `i` 
будем хранить в `balance[i]`
баланс на префиксе `[0;i]`.
```cpp
vector<int> balanse(n);
balanse[0] = ((s[0] == '(') ? 1 : -1);
for (int i = 1; i < n; i++) {
	balanse[i] = balanse[i - 1];
	if (s[i] == '(') {
		++balanse[i];
	}
	else {
		--balanse[i];
	}
}
```

Теперь рассмотрим, как мы будем отвечать на запрос. Для удобство сделаем так, чтобы a было меньше b
```cpp
if (a > b) {
		swap(a, b);
}
```

Если мы меняем одинаковые скобки, то очевидно, что ничего не поменяется (строка останется такой же).
Пусть `s[a] == ')'`, а `s[b] == '('`. Тогда на `[a; b]` значение `balance[i]` увеличится на 2 (так как мы раньше при подсчете balance[a] вычитали единицу, а теперь 
прибавляем 1). 

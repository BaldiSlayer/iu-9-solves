```cpp

#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;


typedef long long ll;
typedef long double ld;

const ld eps = 1e-7 ;
const ld pi = acos(-1.0);

ld n;
ld radius;
ld a;

struct Point {
    ld x, y;
};

vector<Point> polygon;

const ll INF = numeric_limits<ll>::max();

ll hungarian(const vector<vector<ll>>& matrix) {
    ll height = matrix.size(), width = matrix[0].size();

    // Значения, вычитаемые из строк (u) и столбцов (v)
    vector<ll> u(height, 0), v(width, 0);

    // Индекс помеченной клетки в каждом столбце
    vector<ll> markIndices(width, -1);

    // Будем добавлять строки матрицы одну за другой
    for (ll i = 0; i < height; ++i) {
        vector<ll> links(width, -1);
        vector<ll> mins(width, INF);
        vector<ll> visited(width, 0);

        // Разрешение коллизий (создание "чередующейся цепочки" из нулевых элементов)
        ll markedI = i, markedJ = -1, j;
        while (markedI != -1) {
            // Обновим информацию о минимумах в посещенных строках непосещенных столбцов
            // Заодно поместим в j индекс непосещенного столбца с самым маленьким из них
            j = -1;
            for (ll j1 = 0; j1 < width; ++j1)
                if (!visited[j1]) {
                    if (matrix[markedI][j1] - u[markedI] - v[j1] < mins[j1]) {
                        mins[j1] = matrix[markedI][j1] - u[markedI] - v[j1];
                        links[j1] = markedJ;
                    }
                    if (j == -1 || mins[j1] < mins[j])
                        j = j1;
                }

            // Теперь нас интересует элемент с индексами (markIndices[links[j]], j)
            // Произведем манипуляции со строками и столбцами так, чтобы он обнулился
            ll delta = mins[j];
            for (ll j1 = 0; j1 < width; ++j1)
                if (visited[j1]) {
                    u[markIndices[j1]] += delta;
                    v[j1] -= delta;
                }
                else {
                    mins[j1] -= delta;
                }
            u[i] += delta;

            // Если коллизия не разрешена - перейдем к следующей итерации
            visited[j] = 1;
            markedJ = j;
            markedI = markIndices[j];
        }

        // Пройдем по найденной чередующейся цепочке клеток, снимем отметки с
        // отмеченных клеток и поставим отметки на неотмеченные
        for (; links[j] != -1; j = links[j])
            markIndices[j] = markIndices[links[j]];
        markIndices[j] = i;
    }

    // Вернем результат в естественной форме
    ll result = -INF;
    for (ll j = 0; j < width; ++j)
        if (markIndices[j] != -1)
            result = max(result, matrix[markIndices[j]][j]);
    return result;
}

ld dist(Point first, Point scnd) {
    return sqrtl((scnd.x - first.x) * (scnd.x - first.x) + (scnd.y - first.y) * (scnd.y - first.y));
}

void build_polygon(ld angle) {
    ld f0 = pi / 2;
    for (int i = 1; i < n; i++) {
        polygon.push_back({ radius * cos(f0 + angle * i),
            radius * sin(f0 + angle * i)});
    }
}

Point rotate(Point a, ld angle) {
    return { a.x * cos(angle) - a.y * sin(angle), a.x * sin(angle) + a.y * cos(angle) };
}

signed main() {
    ios_base::sync_with_stdio(0); cin.tie(0);

    cin >> n >> radius;

    vector<Point> bugs(n);
    for (int i = 0; i < n; i++) {
        cin >> bugs[i].x >> bugs[i].y;
    }

    // размер стороны правильного n - угольника
    a = radius * 2 * sin(pi / n);
    ld angle = -2 * pi / n;

    polygon = { { 0, radius } };

    build_polygon(angle);

    // теперь нам необходимо тернарным поиском искать подходящий угол
    vector<vector<ll>> matrix1(n, vector<ll>(n)), matrix2(n, vector<ll>(n));

    int count = 100;
    ld l = angle, r = 0, x;
    // пытаемся бинарить наш угол
    for (; count--; ) {
        x = (l + r) / 2;

        for (int i = 0; i < n; i++) {
            Point new1 = rotate(polygon[i], x),
                new2 = rotate(polygon[i], x + eps);
        
            for (int j = 0; j < n; j++) {
                matrix1[i][j] = (long long)(1000000000.0 * dist(new1, bugs[j]));
                matrix2[i][j] = (long long)(1000000000.0 * dist(new2, bugs[j]));
            }
        }

        long long f1 = hungarian(matrix1);
        long long f2 = hungarian(matrix2);

        if (f1 < f2) {
            r = x;
        }
        else {
            l = x;
        }
    }

    ld m1 = (l + r) / 2;
    for (int i = 0; i < n; i++) {
        // повернули на угол m1 и угол m2
        Point new1 = rotate(polygon[i], m1);

        // надо заполнить матрицу инцидентности или как там её..
        for (int j = 0; j < n; j++) {
            matrix1[i][j] = (long long)(1000000000.0 * dist(new1, bugs[j]));
        }
    }

    ld res = hungarian(matrix1) / 1000000000.0;

    cout << fixed << setprecision(10) << res;

    return 0;
}

```


```python
import random

python
n = 200
r = 100
print(n, r, sep=' ')

for i in range(n):
    print(random.randint(-100,100), random.randint(-100,100))'''

import matplotlib.pyplot as plt

n = int(input())
x = []
y = []

for i in range(n):
    a, b = map(float, input().split())
    x.append(a)
    y.append(b)

plt.plot(x, y)
plt.show()
```
